// https://www.learncpp.com/cpp-tutorial/template-classes/

#include <iostream>
#include <algorithm>
#include <cassert>
using namespace std;


template<typename T>
class rohit{
	T x[10];
public:
	void fn(){
		cout<<x;
	}
//	T& operator[](int index){
//		assert(index >= 0 and index < 10);
//		return x[index];
//	}
	T& operator[](int index);

};

template<typename T>
T& rohit<T>::operator[](int index){
	assert(index >= 0 and index < 10);
	return x[index];
}

int main() {
	rohit<int> obj;
	obj[2] = 12;
	cout<<obj[2]; //12
	return 0;
}
---------------------------------------

r.cpp

#include <iostream>
#include <algorithm>
#include <cassert>
using namespace std;
#include "r.h"

/*
  Linker error
  Undefined symbols for architecture x86_64:
  "rohit<int>::operator[](int)", referenced from:
      _main in r.o

	obj[2] = 12; tries to access the [] operator, compilation works fine as compiler stiches r.h contents in r.cpp while
	compilation but when it tries to link the definition with declaration it doesnt find any, since the function call to
	[] operator was never made in rohit.cpp file where it is written. To solve we can put code of rohit.cpp in rohit.h
	but that can affect the compile and linking time.

If you feel that putting the Array.cpp code into the Array.h header makes the header too long/messy, an alternative is to move
the contents of Array.cpp to a new file named Array.inl (.inl stands for inline), and then include Array.inl
at the bottom of the Array.h header (inside the header guard). That yields the same result as putting all 
the code in the header, but helps keep things a little more organized.

Other solutions involve #including .cpp files, but we donâ€™t recommend these because of the non-standard usage of #include.
Another alternative is to use a three-file approach. The template class definition goes in the header.
The template class member functions goes in the code file. Then you add a third file, which contains all of the instantiated classes you need:



  */

int main() {
	rohit<int> obj;
	obj[2] = 12;
	cout<<obj[2]; //12
	return 0;
}



r.h

template<typename T>
class rohit{
	T x[10];
public:
	T& operator[](int index);

};



rohit.cpp


#include "r.h"

template<typename T>
T& rohit<T>::operator[](int index){
	return x[index];
}
